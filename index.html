<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>탄생화 알아보기 (Gemini API 에디션)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@400;700&family=Lora:wght@400;700&display=swap">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="data/birthflowers-compiled.js"></script>
    <script src="data/birthflower-translations-en.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        body { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        .font-ko { font-family: 'Gowun Batang', serif; }
        .font-en { font-family: 'Lora', serif; }
        .hanji-background { background-color: #fdfaf2; background-image: url('https://www.transparenttextures.com/patterns/paper-fibers.png'); }
        .korean-button { background-color: #8c5b40; color: #ffffff; transition: background-color 0.3s; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .korean-button:hover { background-color: #7a4f37; }
        .korean-button:disabled { background-color: #a08c80; cursor: not-allowed; }
        .story-size { width: 360px; height: 640px; position: relative; overflow: hidden; border-radius: 12px; box-shadow: 0 10px 20px rgba(0,0,0,0.15); border: 8px solid #fdfbf5; }
        .story-background { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-size: cover; background-position: center; transition: background-image 0.5s ease-in-out; }
        .story-background::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(to top, rgba(0,0,0,0.7), rgba(0,0,0,0.1) 60%); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- 중요 ---
        // 아래 'YOUR_GEMINI_API_KEY' 부분을 Google AI Studio에서 발급받은 본인의 API 키로 교체하세요.
        // 실제 키는 공개 저장소나 배포된 프런트엔드에 그대로 노출하지 마시고,
        // 테스트라 하더라도 백엔드 프록시 등을 사용해 안전하게 관리하세요.
        const API_KEY = 'YOUR_GEMINI_API_KEY';
        // --- 중요 ---

        const { useState, useEffect, useMemo, Fragment } = React;

        const DATASET_URL = 'data/birthflowers-ko.json';
        const TRANSLATIONS_URL = 'data/birthflower-translations-en.json';
        const HANGUL_REGEX = /[\u3131-\uD79D]/;

        function hasHangul(value) {
            return typeof value === 'string' && HANGUL_REGEX.test(value);
        }

        function createRomanizer() {
            const INITIALS = ['g', 'kk', 'n', 'd', 'tt', 'r', 'm', 'b', 'pp', 's', 'ss', '', 'j', 'jj', 'ch', 'k', 't', 'p', 'h'];
            const MEDIALS = ['a', 'ae', 'ya', 'yae', 'eo', 'e', 'yeo', 'ye', 'o', 'wa', 'wae', 'oe', 'yo', 'u', 'wo', 'we', 'wi', 'yu', 'eu', 'ui', 'i'];
            const FINALS = ['', 'k', 'k', 'ks', 'n', 'nj', 'nh', 't', 'l', 'lk', 'lm', 'lb', 'ls', 'lt', 'lp', 'lh', 'm', 'p', 'ps', 's', 'ss', 'ng', 'j', 'ch', 'k', 't', 'p', 'h'];

            return function romanize(input = '') {
                if (!input) {
                    return '';
                }

                let result = '';
                for (const char of input) {
                    const code = char.charCodeAt(0);
                    if (code < 0xac00 || code > 0xd7a3) {
                        result += char;
                        continue;
                    }

                    const syllableIndex = code - 0xac00;
                    const initialIndex = Math.floor(syllableIndex / 588);
                    const medialIndex = Math.floor((syllableIndex % 588) / 28);
                    const finalIndex = syllableIndex % 28;

                    const initial = INITIALS[initialIndex] || '';
                    const medial = MEDIALS[medialIndex] || '';
                    const final = FINALS[finalIndex] || '';

                    result += initial + medial + final;
                }
                return result;
            };
        }

        const romanizeHangul = createRomanizer();

        function toDisplayCase(value = '') {
            if (!value) {
                return '';
            }
            if (value === value.toLowerCase()) {
                return value
                    .split(/(\s+|-)/)
                    .map(part => {
                        if (!part.trim() || part === '-') {
                            return part;
                        }
                        return part.charAt(0).toUpperCase() + part.slice(1);
                    })
                    .join('');
            }
            return value;
        }

        function capitalizeSentence(value = '') {
            if (!value) {
                return '';
            }
            const trimmed = value.trim();
            if (!trimmed) {
                return '';
            }
            return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
        }

        function findDictionaryValue(dictionary, rawValue) {
            if (!dictionary || !rawValue) {
                return null;
            }
            const normalized = `${rawValue}`.trim();
            if (!normalized) {
                return null;
            }
            const spaced = normalized.replace(/\s+/g, ' ');
            const variants = [normalized, spaced, spaced.replace(/\s+/g, ''), spaced.replace(/\s+/g, '-'), spaced.replace(/\s+/g, '·')];
            for (const candidate of variants) {
                if (Object.prototype.hasOwnProperty.call(dictionary, candidate)) {
                    return dictionary[candidate];
                }
            }
            return null;
        }

        function formatKeywords(keywords = []) {
            if (!Array.isArray(keywords)) {
                if (typeof keywords === 'string') {
                    return keywords;
                }
                return '';
            }
            return keywords.map(keyword => `#${keyword}`).join(' ');
        }

        function normalizeSourceData(rawKo) {
            if (!rawKo) {
                throw new Error('No birth flower dataset available.');
            }

            const entries = {};

            if (Array.isArray(rawKo.months)) {
                rawKo.months.forEach(monthEntry => {
                    const month = Number(monthEntry.month);
                    (monthEntry.days || []).forEach(dayEntry => {
                        const day = Number(dayEntry.day);
                        const key = `${month}-${day}`;
                        entries[key] = {
                            key,
                            month,
                            day,
                            name: dayEntry.name,
                            enName: dayEntry.enName,
                            keywords: Array.isArray(dayEntry.keywords) ? dayEntry.keywords : [],
                            description: dayEntry.description,
                            goodMatch: dayEntry.goodMatch,
                            badMatch: dayEntry.badMatch,
                        };
                    });
                });
                return entries;
            }

            if (typeof rawKo === 'object' && rawKo !== null) {
                Object.entries(rawKo).forEach(([key, value]) => {
                    if (!key.includes('-')) {
                        return;
                    }
                    const [month, day] = key.split('-').map(Number);
                    const keywords = typeof value.keywords === 'string'
                        ? value.keywords.split('#').map(token => token.trim()).filter(Boolean)
                        : [];
                    entries[key] = {
                        key,
                        month,
                        day,
                        name: value.name,
                        enName: value.en_name || value.enName,
                        keywords,
                        description: value.description,
                        goodMatch: value.goodMatch,
                        badMatch: value.badMatch,
                    };
                });
                if (Object.keys(entries).length > 0) {
                    return entries;
                }
            }

            throw new Error('Unrecognized birth flower dataset format.');
        }

        function buildKoreanBranch(sourceEntries) {
            const result = {};
            Object.values(sourceEntries).forEach(entry => {
                result[entry.key] = {
                    name: entry.name,
                    en_name: entry.enName || entry.name,
                    keywords: formatKeywords(entry.keywords),
                    description: entry.description,
                    goodMatch: entry.goodMatch,
                    badMatch: entry.badMatch,
                };
            });
            return result;
        }

        function createTranslationSystem(translations = {}) {
            const nameDictionary = translations.names || {};
            const keywordDictionary = translations.keywords || {};

            const translateName = (koreanName, fallbackName, enName) => {
                const dictionaryValue = findDictionaryValue(nameDictionary, koreanName);
                const asciiFallback = !hasHangul(enName) && enName ? enName : (!hasHangul(fallbackName) && fallbackName ? fallbackName : '');
                const base = dictionaryValue || asciiFallback || romanizeHangul(koreanName || '');
                return toDisplayCase(base);
            };

            const translateMatch = (value, fallback) => {
                if (!value) {
                    return '';
                }
                const dictionaryValue = findDictionaryValue(nameDictionary, value);
                const asciiFallback = !hasHangul(fallback) && fallback ? fallback : '';
                const base = dictionaryValue || asciiFallback || romanizeHangul(value);
                return toDisplayCase(base);
            };

            const translateKeywords = (keywordsList, fallbackString) => {
                const list = Array.isArray(keywordsList) ? keywordsList : [];
                const fallbackTokens = typeof fallbackString === 'string'
                    ? fallbackString.split(/\s+/).filter(Boolean).map(token => token.startsWith('#') ? token.slice(1) : token)
                    : [];

                return list.map((keyword, index) => {
                    const fallbackToken = fallbackTokens[index];
                    const dictionaryValue = findDictionaryValue(keywordDictionary, keyword);
                    const asciiFallback = !hasHangul(fallbackToken) && fallbackToken ? fallbackToken : '';
                    const base = dictionaryValue || asciiFallback || romanizeHangul(keyword);
                    return `#${toDisplayCase(base)}`;
                }).join(' ');
            };

            const translateDescription = (value, fallback) => {
                const asciiFallback = !hasHangul(fallback) && fallback ? fallback : '';
                if (asciiFallback) {
                    return asciiFallback;
                }
                const romanized = romanizeHangul(value || '');
                if (!romanized) {
                    return '';
                }
                return capitalizeSentence(romanized);
            };

            return function translateEntry(entry, fallback = {}) {
                return {
                    name: translateName(entry.name, fallback.name || fallback.en_name, entry.enName),
                    en_name: translateName(entry.name, fallback.en_name || fallback.name, entry.enName),
                    keywords: translateKeywords(entry.keywords, fallback.keywords),
                    description: translateDescription(entry.description, fallback.description),
                    goodMatch: translateMatch(entry.goodMatch, fallback.goodMatch),
                    badMatch: translateMatch(entry.badMatch, fallback.badMatch),
                };
            };
        }

        function buildEnglishBranch(sourceEntries, translationDictionary, fallbackEnglishEntries = {}) {
            const translateEntry = createTranslationSystem(translationDictionary);
            const result = {};
            Object.values(sourceEntries).forEach(entry => {
                const fallbackEntry = fallbackEnglishEntries[entry.key] || {};
                result[entry.key] = translateEntry(entry, fallbackEntry);
            });
            return result;
        }

        async function fetchWithFallback(url, signal, fallbackProvider, label) {
            const fetchJson = async () => {
                const response = await fetch(url, { signal });
                if (!response.ok) {
                    throw new Error(`Failed to load ${url} (status ${response.status})`);
                }
                return response.json();
            };

            try {
                return await fetchJson();
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw error;
                }
                console.warn(`Failed to fetch ${label || url}:`, error);
                if (typeof fallbackProvider === 'function') {
                    const fallback = fallbackProvider();
                    if (fallback) {
                        return fallback;
                    }
                }
                throw error;
            }
        }

        async function fetchBirthFlowerData(signal) {
            const [rawKo, translationDictionary] = await Promise.all([
                fetchWithFallback(DATASET_URL, signal, () => window?.BIRTHFLOWER_DATASET?.ko, 'birth flower base dataset'),
                fetchWithFallback(TRANSLATIONS_URL, signal, () => window?.BIRTHFLOWER_TRANSLATIONS_EN, 'translation dictionary'),
            ]);

            const sourceEntries = normalizeSourceData(rawKo);
            const fallbackEnglish = window?.BIRTHFLOWER_DATASET?.en || {};

            return {
                ko: buildKoreanBranch(sourceEntries),
                en: buildEnglishBranch(sourceEntries, translationDictionary, fallbackEnglish),
            };
        }
        const translations = {
            ko: {
                mainTitle: "나의 탄생화 알아보기", mainSubtitle: "당신이 태어난 날, 숨겨진 특별한 의미를 찾아보세요.", resultButton: "나의 탄생화 확인하기", loadingText: "AI가 당신의 꽃을 그리고 있어요...", shareButton: "이미지 저장하기", retryButton: "처음으로", modalTitle: "이미지 저장", modalText: "아래 버튼을 눌러 이미지를 저장하세요.", downloadButton: "저장하기", closeButton: "닫기", months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"], days: "일", errorAlert: "선택하신 날짜의 탄생화 정보를 찾을 수 없습니다.", captureError: "이미지 캡처에 실패했습니다. 다시 시도해주세요.", sharingText: "이미지 준비 중...", debouncingText: "확인 중...",
                apiErrorTitle: "이미지 생성 실패", apiErrorText: "API 키가 유효한지, 할당량이 초과되지 않았는지 확인해주세요.",
                goodMatchLabel: "💚 잘 맞는 궁합", badMatchLabel: "💔 아쉬운 궁합",
                datasetLoading: "탄생화 데이터를 불러오는 중입니다...",
                datasetErrorTitle: "데이터를 불러올 수 없습니다",
                datasetErrorDescription: "페이지를 새로고침하거나 잠시 후 다시 시도해주세요.",
                datasetRetryButton: "다시 불러오기",
            },
            en: {
                mainTitle: "Discover Your Birth Flower", mainSubtitle: "Find the hidden, special meaning behind the day you were born.", resultButton: "Find My Birth Flower", loadingText: "AI is painting your flower...", shareButton: "Save Image", retryButton: "Start Over", modalTitle: "Save Image", modalText: "Press the button below to save the image.", downloadButton: "Save", closeButton: "Close", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], days: "", errorAlert: "Could not find birth flower information for the selected date.", captureError: "Failed to capture image. Please try again.", sharingText: "Preparing image...", debouncingText: "Checking...",
                apiErrorTitle: "Image Generation Failed", apiErrorText: "Please check if your API key is valid and the quota has not been exceeded.",
                goodMatchLabel: "💚 Good Match", badMatchLabel: "💔 Bad Match",
                datasetLoading: "Loading birth flower data...",
                datasetErrorTitle: "Unable to Load Data",
                datasetErrorDescription: "Please refresh the page or try again in a moment.",
                datasetRetryButton: "Retry",
            }
        };

        async function generateImageWithGemini(flowerName) {
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${API_KEY}`;
            const prompt = `A beautiful Korean folk painting (Minhwa) of a ${flowerName} flower, on aged hanji paper, simple and elegant style, vibrant colors`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { responseModalities: ['TEXT', 'IMAGE'] }
                    })
                });

                if (!response.ok) {
                    let errorDetails = `Status: ${response.status}.`;
                    try {
                        const errorData = await response.json();
                        errorDetails += ` Message: ${errorData.error?.message || 'Unknown API error.'}`;
                         if (response.status === 429) {
                            errorDetails += ' (Quota exceeded. Please try again later.)';
                        }
                    } catch (e) {
                        errorDetails += ` Could not parse server response.`;
                    }
                    return { imageUrl: null, error: errorDetails };
                }

                const result = await response.json();
                const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

                if (!base64Data) {
                    return { imageUrl: null, error: "Could not find image data in API response." };
                }
                return { imageUrl: `data:image/png;base64,${base64Data}`, error: null };

            } catch (error) {
                console.error("Network or other error:", error);
                return { imageUrl: null, error: "Please check your network connection or try again later." };
            }
        }

        function SetupPage() {
            return (
                <div className="w-full max-w-md text-center bg-[#fdfbf5] p-8 rounded-lg shadow-lg border border-[#dcd3c3]">
                    <h1 className="text-3xl font-bold text-red-600 mb-4">⚠️ 설정 필요</h1>
                    <p className="text-lg text-[#6d5d4b] mb-6">
                        Gemini API 키가 아직 설정되지 않았습니다. 앱을 사용하려면 코드를 직접 수정해야 합니다.
                    </p>
                    <div className="text-left bg-gray-100 p-4 rounded-lg">
                        <p className="font-bold mb-2">수정 방법:</p>
                        <ol className="list-decimal list-inside space-y-2 text-gray-700">
                            <li><code>index.html</code> 파일을 엽니다.</li>
                            <li>파일 상단의 <code>const API_KEY = 'YOUR_GEMINI_API_KEY';</code> 라인을 찾습니다.</li>
                            <li><code>'YOUR_GEMINI_API_KEY'</code> 부분을 실제 본인의 API 키로 교체한 후 저장하세요.</li>
                        </ol>
                    </div>
                </div>
            );
        }

        function LanguageToggle({ language, onToggle }) {
            return (
                <div className="absolute top-4 right-4 z-10">
                    <button onClick={onToggle} className="bg-white/50 backdrop-blur-sm text-[#5a3a29] font-bold py-2 px-4 rounded-full border border-[#dcd3c3]">
                        {language === 'ko' ? 'EN' : 'KO'}
                    </button>
                </div>
            );
        }

        function App() {
            const [language, setLanguage] = useState('ko');
            const [birthFlowers, setBirthFlowers] = useState(null);
            const [isDataLoading, setIsDataLoading] = useState(true);
            const [dataError, setDataError] = useState(null);
            const [showResult, setShowResult] = useState(false);
            const [resultData, setResultData] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [apiError, setApiError] = useState(null);
            const [imageCache, setImageCache] = useState({});
            const t = translations[language];

            const toggleLanguage = () => setLanguage(prev => (prev === 'ko' ? 'en' : 'ko'));

            const availableDaysByMonth = useMemo(() => {
                if (!birthFlowers?.ko) {
                    return {};
                }

                const monthMap = {};

                Object.keys(birthFlowers.ko).forEach(key => {
                    const [month, day] = key.split('-').map(Number);
                    if (!monthMap[month]) {
                        monthMap[month] = new Set();
                    }
                    monthMap[month].add(day);
                });

                const result = {};
                Object.keys(monthMap).forEach(month => {
                    result[Number(month)] = Array.from(monthMap[month]).sort((a, b) => a - b);
                });

                return result;
            }, [birthFlowers]);

            const loadBirthFlowerData = (controller = new AbortController()) => {
                setIsDataLoading(true);
                setDataError(null);
                setBirthFlowers(null);
                fetchBirthFlowerData(controller.signal)
                    .then(data => {
                        setBirthFlowers(data);
                        setIsDataLoading(false);
                    })
                    .catch(error => {
                        if (error.name === 'AbortError') {
                            return;
                        }
                        console.error('Failed to load birth flower data:', error);
                        setDataError(error.message);
                        setIsDataLoading(false);
                    });
                return controller;
            };

            useEffect(() => {
                const controller = loadBirthFlowerData();
                return () => controller.abort();
            }, []);

            useEffect(() => {
                if (!showResult || !birthFlowers) {
                    return;
                }

                setResultData(prev => {
                    if (!prev) {
                        return prev;
                    }

                    const currentKey = Object.keys(birthFlowers.ko).find(key => birthFlowers.ko[key].en_name === prev.en_name);
                    if (!currentKey) {
                        return prev;
                    }

                    const [month, day] = currentKey.split('-');
                    const newDisplayData = birthFlowers[language][currentKey];
                    const nextData = {
                        ...newDisplayData,
                        imageUrl: prev.imageUrl,
                        dateText: language === 'ko' ? `${month}월 ${day}일의 당신` : `You on ${translations.en.months[month-1]} ${day}`
                    };

                    const isSame =
                        prev.name === nextData.name &&
                        prev.keywords === nextData.keywords &&
                        prev.description === nextData.description &&
                        prev.goodMatch === nextData.goodMatch &&
                        prev.badMatch === nextData.badMatch &&
                        prev.dateText === nextData.dateText;

                    return isSame ? prev : nextData;
                });
            }, [language, showResult, birthFlowers]);

            const handleDataRetry = () => {
                loadBirthFlowerData();
            };

            if (isDataLoading) {
                return (
                    <div className={`hanji-background min-h-screen flex items-center justify-center p-4 ${language === 'ko' ? 'font-ko' : 'font-en'}`}>
                        <LanguageToggle language={language} onToggle={toggleLanguage} />
                        <div className="w-full max-w-md text-center bg-[#fdfbf5] p-8 rounded-lg shadow-lg border border-[#dcd3c3]">
                            <p className="text-lg text-[#6d5d4b]">{t.datasetLoading}</p>
                        </div>
                    </div>
                );
            }

            if (dataError) {
                return (
                    <div className={`hanji-background min-h-screen flex items-center justify-center p-4 ${language === 'ko' ? 'font-ko' : 'font-en'}`}>
                        <LanguageToggle language={language} onToggle={toggleLanguage} />
                        <div className="w-full max-w-md text-center bg-[#fdfbf5] p-8 rounded-lg shadow-lg border border-[#dcd3c3] space-y-4">
                            <h2 className="text-2xl font-bold text-red-600">{t.datasetErrorTitle}</h2>
                            <p className="text-[#6d5d4b]">{t.datasetErrorDescription}</p>
                            <p className="text-sm text-[#8c5b40] break-all">{dataError}</p>
                            <button onClick={handleDataRetry} className="korean-button w-full py-3 text-lg font-bold rounded-lg">{t.datasetRetryButton}</button>
                        </div>
                    </div>
                );
            }

            if (!API_KEY || API_KEY === 'YOUR_GEMINI_API_KEY') {
                return (
                    <div className={`hanji-background min-h-screen flex items-center justify-center p-4 ${language === 'ko' ? 'font-ko' : 'font-en'}`}>
                        <LanguageToggle language={language} onToggle={toggleLanguage} />
                        <SetupPage />
                    </div>
                );
            }

            const handleShowResult = async (month, day) => {
                if (!birthFlowers || !birthFlowers.ko) {
                    alert(t.errorAlert);
                    return;
                }

                const key = `${month}-${day}`;
                const baseFlowerData = birthFlowers.ko[key];

                if (!baseFlowerData) {
                    alert(t.errorAlert);
                    return;
                }

                setShowResult(true);
                setIsLoading(true);
                setApiError(null);
                setResultData(null);

                const displayFlowerData = birthFlowers[language][key];

                if (imageCache[key]) {
                    setResultData({
                        ...displayFlowerData,
                        imageUrl: imageCache[key],
                        dateText: language === 'ko' ? `${month}월 ${day}일의 당신` : `You on ${translations.en.months[month-1]} ${day}`
                    });
                    setIsLoading(false);
                    return;
                }

                const { imageUrl, error } = await generateImageWithGemini(baseFlowerData.en_name);

                if (error) {
                    setApiError(error);
                } else {
                    setImageCache(prevCache => ({ ...prevCache, [key]: imageUrl }));
                    setResultData({
                        ...displayFlowerData,
                        imageUrl,
                        dateText: language === 'ko' ? `${month}월 ${day}일의 당신` : `You on ${translations.en.months[month-1]} ${day}`
                    });
                }
                setIsLoading(false);
            };

            const handleRetry = () => {
                setShowResult(false);
                setResultData(null);
                setApiError(null);
            };

            return (
                <div className={`hanji-background min-h-screen flex items-center justify-center p-4 ${language === 'ko' ? 'font-ko' : 'font-en'}`}>
                    <LanguageToggle language={language} onToggle={toggleLanguage} />
                    {!showResult ? (
                        <StartPage t={t} onShowResult={handleShowResult} availableDaysByMonth={availableDaysByMonth} />
                    ) : (
                        <ResultPage t={t} resultData={resultData} isLoading={isLoading} apiError={apiError} onRetry={handleRetry} />
                    )}
                </div>
            );
        }

        function StartPage({ t, onShowResult, availableDaysByMonth }) {
            const months = useMemo(() => (
                Object.keys(availableDaysByMonth || {})
                    .map(Number)
                    .sort((a, b) => a - b)
            ), [availableDaysByMonth]);

            const initialMonth = months[0] || 1;
            const initialDay = (availableDaysByMonth?.[initialMonth] || [1])[0];

            const [month, setMonth] = useState(initialMonth);
            const [day, setDay] = useState(initialDay);
            const [isDebouncing, setIsDebouncing] = useState(false);

            useEffect(() => {
                const validDays = availableDaysByMonth?.[month] || [];
                if (validDays.length === 0) {
                    return;
                }

                if (!validDays.includes(day)) {
                    setDay(validDays[0]);
                }
            }, [month, day, availableDaysByMonth]);

            useEffect(() => {
                if (!months.includes(month)) {
                    setMonth(initialMonth);
                    setDay(initialDay);
                }
            }, [months, initialMonth, initialDay, month]);

            const handleClick = () => {
                if (isDebouncing) return;

                setIsDebouncing(true);
                onShowResult(month, day);

                setTimeout(() => {
                    setIsDebouncing(false);
                }, 3000);
            };

            return (
                <div className="w-full max-w-md text-center">
                    <h1 className="text-4xl md:text-5xl font-bold text-[#5a3a29] mb-3">{t.mainTitle}</h1>
                    <p className="text-lg text-[#6d5d4b] mb-10">{t.mainSubtitle}</p>
                    <div className="bg-[#fdfbf5] p-8 rounded-lg shadow-lg border border-[#dcd3c3]">
                        <div className="flex space-x-4 mb-8">
                            <select value={month} onChange={(e) => setMonth(Number(e.target.value))} className="w-full p-3 bg-white border border-[#dcd3c3] rounded-md text-lg focus:outline-none focus:ring-2 focus:ring-[#8c5b40]">
                                {months.map(monthNumber => (
                                    <option key={monthNumber} value={monthNumber}>
                                        {t.months[monthNumber - 1] || `${monthNumber}${t.days}`}
                                    </option>
                                ))}
                            </select>
                            <select value={day} onChange={(e) => setDay(Number(e.target.value))} className="w-full p-3 bg-white border border-[#dcd3c3] rounded-md text-lg focus:outline-none focus:ring-2 focus:ring-[#8c5b40]">
                                {(availableDaysByMonth?.[month] || []).map(d => (
                                    <option key={d} value={d}>{`${d}${t.days}`}</option>
                                ))}
                            </select>
                        </div>
                        <button onClick={handleClick} disabled={isDebouncing} className="korean-button w-full py-4 text-xl font-bold rounded-lg">
                            {isDebouncing ? t.debouncingText : t.resultButton}
                        </button>
                    </div>
                </div>
            );
        }

        function ResultPage({ t, resultData, isLoading, apiError, onRetry }) {
            const [isSharing, setIsSharing] = useState(false);
            const [showModal, setShowModal] = useState(false);
            const [downloadUrl, setDownloadUrl] = useState('');

            const handleShare = async () => {
                if (!resultData || isLoading || apiError) return;
                setIsSharing(true);
                try {
                    const captureArea = document.getElementById('capture-area');
                    const canvas = await window.html2canvas(captureArea, { useCORS: true, scale: 2 });
                    setDownloadUrl(canvas.toDataURL('image/png'));
                    setShowModal(true);
                } catch (error) {
                    console.error('Error capturing image:', error);
                    alert(t.captureError);
                } finally {
                    setIsSharing(false);
                }
            };

            const renderContent = () => {
                if (isLoading) {
                    return (
                        <div className="absolute inset-0 bg-black bg-opacity-60 flex flex-col items-center justify-center z-20">
                            <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-white"></div>
                            <p className="text-white mt-4 text-lg">{t.loadingText}</p>
                        </div>
                    );
                }

                if (apiError) {
                    return (
                        <div className="absolute inset-0 bg-red-800 bg-opacity-90 flex flex-col items-center justify-center z-20 p-4 text-white text-center">
                            <h3 className="text-2xl font-bold mb-4">{t.apiErrorTitle}</h3>
                            <p className="text-sm">{t.apiErrorText}</p>
                            <p className="text-xs mt-2 bg-red-900 p-2 rounded break-all">Error: {apiError}</p>
                        </div>
                    );
                }

                if (resultData) {
                    return (
                        <Fragment>
                            <div className="story-background" style={{ backgroundImage: `url(${resultData.imageUrl})` }}></div>
                            <div className="z-10 relative h-full flex flex-col justify-between transition-opacity duration-500">
                                <div>
                                    <p className="text-xl opacity-80">{resultData.dateText}</p>
                                    <h2 className="text-4xl font-bold mt-1" style={{ textShadow: '2px 2px 4px rgba(0,0,0,0.5)' }}>{resultData.name}</h2>
                                    <div className="mt-8">
                                        <p className="text-lg font-bold" style={{ textShadow: '1px 1px 3px rgba(0,0,0,0.7)' }}>{resultData.keywords}</p>
                                        <p className="text-base leading-relaxed bg-black bg-opacity-30 p-3 rounded-lg mt-2">{resultData.description}</p>
                                    </div>
                                </div>
                                <div>
                                    <div className="text-sm bg-black bg-opacity-30 p-3 rounded-lg">
                                        <div className="flex justify-around">
                                            <div><p className="opacity-80">{t.goodMatchLabel}</p><p className="font-bold text-base">{resultData.goodMatch}</p></div>
                                            <div><p className="opacity-80">{t.badMatchLabel}</p><p className="font-bold text-base">{resultData.badMatch}</p></div>
                                        </div>
                                    </div>
                                    <div className="mt-4 text-center">
                                        <img src="./Logo_Ongi_C.png" alt="Ongi Logo" className="h-10 mx-auto" />
                                    </div>
                                </div>
                            </div>
                        </Fragment>
                    );
                }
                return null;
            };

            return (
                <div className="w-full max-w-md text-center">
                    <div id="capture-area" className="story-size flex flex-col justify-between p-8 text-center text-white bg-gray-900">
                       {renderContent()}
                    </div>

                    <div className="mt-6 flex flex-col space-y-3">
                         <button onClick={handleShare} disabled={isSharing || isLoading || !resultData || apiError} className="korean-button w-full py-3 text-lg font-bold rounded-lg">
                            {isSharing ? t.sharingText : t.shareButton}
                         </button>
                         <button onClick={onRetry} className="w-full py-3 text-lg font-bold rounded-lg bg-[#dcd3c3] text-[#5a3a29] hover:bg-[#c9bfad] transition">{t.retryButton}</button>
                    </div>

                    {showModal && (
                         <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
                            <div className="bg-[#fdfbf5] rounded-lg p-8 text-center max-w-sm w-full shadow-xl">
                                <h3 className="text-2xl font-bold text-[#5a3a29] mb-4">{t.modalTitle}</h3>
                                <p className="text-lg text-[#6d5d4b] mb-6">{t.modalText}</p>
                                <a href={downloadUrl} download="my_birth_flower.png" className="korean-button w-full py-3 text-lg font-bold rounded-lg block mb-3">{t.downloadButton}</a>
                                <button onClick={() => setShowModal(false)} className="w-full py-3 text-lg font-bold rounded-lg bg-[#dcd3c3] text-[#5a3a29] hover:bg-[#c9bfad] transition">{t.closeButton}</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>

